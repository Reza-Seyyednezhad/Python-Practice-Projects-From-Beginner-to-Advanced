# order_invoice_manager

"""
Guide to the Exercise (Generated by ChatGPT)

Order & Invoice Manager – Advanced OOP & System Design Exercise
1. Overview
The Order & Invoice Manager is a modular, event-driven backend system designed to simulate a real-world order processing workflow.
This project focuses on:
    - Object-Oriented Design (OOP)
    - Design Patterns (Factory, Observer, Strategy)
    - Structured Logging (with rotation)
    - Domain Modeling
    - Error Handling & Transaction Integrity  
    - Clean Architecture Principles
The system manages the full lifecycle of an order — from creation to invoice generation and payment confirmation.

2. Problem Statement
Design and implement a scalable and extensible system that:
    - Allows customers to create orders containing multiple items.
    - Automatically generates invoices for confirmed orders.
    - Supports multiple payment strategies.
    - Tracks order and invoice states.
    - Notifies subscribed observers when important events occur.
    - Implements advanced logging with log rotation.
The system must follow clean architectural principles and proper separation of concerns.

3. Functional Requirements
3.1 Order Management
    - Create a new order.
    - Add multiple items to an order.
    - Calculate total order amount.
    - Cancel an order (only if not paid).
    - Retrieve order summary.
Each order must include:
    - Unique order ID
    - Customer information
    - List of items
    - Order status (Pending, Confirmed, Cancelled)
    - Total amount
    - Creation timestamp

3.2 Invoice Management
    - Generate invoice from a confirmed order.
    - Prevent duplicate invoice generation.
    - Track invoice status (Pending, Paid, Cancelled).
    - Store invoice issue timestamp.
    - Link invoice to its originating order.

3.3 Payment Handling
The system must support multiple payment strategies:
    - Credit Card
    - Digital Wallet
    - Cryptocurrency

Each payment strategy must:
    - Validate the payment
    - Return success or failure
    - Update invoice status accordingly
The payment mechanism must be implemented using the Strategy Pattern.

3.4 Event Notification (Observer Pattern)
The system must notify observers when the following events occur:
    - Order Created
    - Invoice Generated
    - Payment Completed
    - Payment Failed
    - Order Cancelled
Observers may include:
    - Logging Observer
    - Email Notification Observer
    - Analytics Observer
The Subject (Event Manager) must not depend on concrete observer implementations.

3.5 Logging (Advanced Logging Requirement)
The logging system must meet the following constraints:
1. All log levels must be written to a file.
2. Only ERROR and CRITICAL logs should be displayed in the console.
3. Log format must include:
    - Timestamp
    - Log Level
    - Module Name
    - Function Name
    - Line Number
    - Contextual ID (Order ID / Invoice ID)
    - Message
4. Log file must use size-based rotation (e.g., 5MB per file).
The logging system must be centralized and reusable.

4. Non-Functional Requirements
Code must follow OOP best practices.
    - Proper exception hierarchy must be implemented.
    - No business logic inside UI layer.
    - The system must be easily extensible.
    - No hard-coded dependencies between components.
    - Use type hints where applicable.

5. Design Constraints
You must implement the following design patterns:
    - Factory Pattern
        - Used to generate invoices dynamically.
    - Observer Pattern
        - Used for event notifications.
    - Strategy Pattern
        - Used for payment processing.
    - Optional (Bonus):
        - Singleton for logging configuration
        - Repository abstraction for persistence layer

6. Suggested Architecture
order_invoice_manager/
│
├── models/
│   ├── customer.py
│   ├── order.py
│   ├── order_item.py
│   └── invoice.py
│
├── services/
│   ├── order_service.py
│   ├── invoice_service.py
│   └── payment_service.py
│
├── patterns/
│   ├── observer.py
│   ├── factory.py
│   └── strategy.py
│
├── logging_config.py
├── exceptions.py
└── main.py

7. Expected Workflow
A typical execution scenario:
1. Create customer.
2. Create order with multiple items.
3. Confirm order.
4. Generate invoice.
5. Process payment.
6. Trigger observers.
7. Log all operations.
8. Attempt invalid operation (e.g., double payment) → raise exception.

8. Edge Cases to Handle
    - Generating invoice for cancelled order.
    - Paying an already paid invoice.
    - Creating order with empty item list.
    - Negative item price.
    - Cancelling order after payment.
    - Invalid payment method.

9. Exception Handling
Create a custom exception hierarchy:
    - BaseApplicationException
        - OrderException
        - InvoiceException
        - PaymentException
        - ValidationException
Exceptions must provide meaningful error messages and be logged properly.

10. Evaluation Criteria
Your implementation will be evaluated based on:
    - Code readability
    - Proper encapsulation
    - Pattern correctness
    - Logging quality
    - Error handling
    - Modularity
    - Extensibility
    - Clean separation of concerns


11. Learning Outcomes
After completing this exercise, you should understand:
    - How to model real-world financial workflows
    - How to decouple systems using Observer pattern
    - How to apply Strategy pattern in payment systems
    - How to implement production-grade logging
    - How to design scalable, maintainable software systems

"""

"""
Order & Invoice Manager (Production-Level)

Features:
- Clean Architecture (Domain, Service, Observer)
- Observer Pattern for event-driven notifications
- Enum-based state management
- Advanced logging with rotation
- Exception hierarchy
- Proper validation and lifecycle control
- Resume-ready, production-style implementation
"""

import logging
from logging.handlers import RotatingFileHandler
from abc import ABC, abstractmethod
from enum import Enum
from datetime import datetime
from typing import List, Optional

# =========================================================
# Logging Configuration (Production Level)
# =========================================================

logger = logging.getLogger("order_invoice_manager")
logger.setLevel(logging.DEBUG)

formatter = logging.Formatter(
    "%(asctime)s | %(levelname)s | %(name)s | %(funcName)s:%(lineno)d | %(message)s",
    "%Y-%m-%d %H:%M:%S"
)

file_handler = RotatingFileHandler(
    "./files/order_invoice_manager.log",
    maxBytes=5_000_000,
    backupCount=5,
    encoding="utf-8"
)
file_handler.setLevel(logging.DEBUG)
file_handler.setFormatter(formatter)

console_handler = logging.StreamHandler()
console_handler.setLevel(logging.ERROR)
console_handler.setFormatter(formatter)

logger.addHandler(file_handler)
logger.addHandler(console_handler)

# =========================================================
# Exception Hierarchy
# =========================================================

class OrderError(Exception):
    pass

class OrderNotFoundError(OrderError):
    pass

class InvalidOrderStateError(OrderError):
    pass

class InvoiceError(Exception):
    pass

class InvoiceNotFoundError(InvoiceError):
    pass

# =========================================================
# Enums
# =========================================================

class OrderStatus(Enum):
    PENDING = "Pending"
    CONFIRMED = "Confirmed"
    CANCELLED = "Cancelled"
    PAID = "Paid"


class InvoiceStatus(Enum):
    PENDING = "Pending"
    PAID = "Paid"
    CANCELLED = "Cancelled"

# =========================================================
# Observer Pattern
# =========================================================

class Event:
    def __init__(self, name: str, data: str):
        self.name = name
        self.data = data
        self.timestamp = datetime.now()

    def __str__(self):
        return f"{self.name} | {self.data} | {self.timestamp}"


class Observer(ABC):

    @abstractmethod
    def update(self, event: Event) -> None:
        pass


class EventManager:

    def __init__(self):
        self._observers: List[Observer] = []

    def subscribe(self, observer: Observer) -> None:
        logger.debug(f"Observer subscribed: {observer.__class__.__name__}")
        self._observers.append(observer)

    def unsubscribe(self, observer: Observer) -> None:
        self._observers.remove(observer)

    def notify(self, event: Event) -> None:
        logger.debug(f"Notifying observers: {event}")
        for observer in self._observers:
            observer.update(event)


# Concrete Observers

class LoggingObserver(Observer):

    def update(self, event: Event) -> None:
        logger.info(f"[LoggingObserver] {event}")


class EmailObserver(Observer):

    def update(self, event: Event) -> None:
        logger.info(f"[EmailObserver] Email sent for event: {event.name}")


class MetricsObserver(Observer):

    def update(self, event: Event) -> None:
        logger.info(f"[MetricsObserver] Metrics recorded for: {event.name}")


# =========================================================
# Domain Models
# =========================================================

class Order:

    def __init__(self, order_id: int, customer_name: str):

        self.order_id = order_id
        self.customer_name = customer_name

        self.items: List[tuple[str, float]] = []

        self.total_amount: float = 0.0

        self.status = OrderStatus.PENDING

        self.created_at = datetime.now()

        logger.debug(f"Order created: id={order_id}")

    def add_item(self, name: str, price: float):

        if self.status != OrderStatus.PENDING:
            raise InvalidOrderStateError("Cannot add items after confirmation")

        if price <= 0:
            raise ValueError("Price must be positive")

        self.items.append((name, price))
        self.total_amount += price

        logger.debug(f"Item added to order {self.order_id}: {name}, {price}")

    def confirm(self):

        if not self.items:
            raise OrderError("Cannot confirm empty order")

        self.status = OrderStatus.CONFIRMED

        logger.debug(f"Order confirmed: {self.order_id}")

    def cancel(self):

        if self.status == OrderStatus.PAID:
            raise InvalidOrderStateError("Cannot cancel paid order")

        self.status = OrderStatus.CANCELLED

        logger.debug(f"Order cancelled: {self.order_id}")


class Invoice:

    def __init__(self, invoice_id: int, order: Order):

        if order.status != OrderStatus.CONFIRMED:
            raise InvoiceError("Order must be confirmed")

        self.invoice_id = invoice_id
        self.order = order

        self.amount = order.total_amount

        self.status = InvoiceStatus.PENDING

        self.created_at = datetime.now()

        logger.debug(f"Invoice created: id={invoice_id}")

    def mark_paid(self):

        if self.status == InvoiceStatus.PAID:
            raise InvoiceError("Already paid")

        self.status = InvoiceStatus.PAID

        self.order.status = OrderStatus.PAID

        logger.debug(f"Invoice paid: id={self.invoice_id}")


# =========================================================
# Services
# =========================================================

class OrderService:

    def __init__(self, event_manager: EventManager):

        self._orders: List[Order] = []

        self._next_id = 1

        self._events = event_manager

    def create_order(self, customer_name: str) -> Order:

        order = Order(self._next_id, customer_name)

        self._orders.append(order)

        self._next_id += 1

        self._events.notify(Event(
            "ORDER_CREATED",
            f"Order {order.order_id} created for {customer_name}"
        ))

        return order

    def find_order(self, order_id: int) -> Order:

        for o in self._orders:
            if o.order_id == order_id:
                return o

        raise OrderNotFoundError(order_id)


class InvoiceService:

    def __init__(self, event_manager: EventManager):

        self._invoices: List[Invoice] = []

        self._next_id = 1

        self._events = event_manager

    def create_invoice(self, order: Order) -> Invoice:

        invoice = Invoice(self._next_id, order)

        self._invoices.append(invoice)

        self._next_id += 1

        self._events.notify(Event(
            "INVOICE_CREATED",
            f"Invoice {invoice.invoice_id} created for order {order.order_id}"
        ))

        return invoice

    def pay_invoice(self, invoice: Invoice):

        invoice.mark_paid()

        self._events.notify(Event(
            "INVOICE_PAID",
            f"Invoice {invoice.invoice_id} paid"
        ))


# =========================================================
# Demo / Main
# =========================================================

def main():

    logger.info("System started")

    event_manager = EventManager()

    event_manager.subscribe(LoggingObserver())
    event_manager.subscribe(EmailObserver())
    event_manager.subscribe(MetricsObserver())

    order_service = OrderService(event_manager)
    invoice_service = InvoiceService(event_manager)

    order = order_service.create_order("Alice")

    order.add_item("Laptop", 1500)
    order.add_item("Mouse", 50)

    order.confirm()

    invoice = invoice_service.create_invoice(order)

    invoice_service.pay_invoice(invoice)

    logger.info("System finished")


if __name__ == "__main__":
    main()
